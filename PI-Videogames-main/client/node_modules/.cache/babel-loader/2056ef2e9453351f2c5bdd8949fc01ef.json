{"ast":null,"code":"var _jsxFileName = \"/Users/joaco/Desktop/Henry/PI-videogames/PI-Videogames-main/client/src/components/Form/Form.js\",\n    _s = $RefreshSig$();\n\nimport React from 'react';\nimport { NavLink } from 'react-router-dom';\nimport './Form.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport function validate(user) {\n  // Creamos función validadora de datos de los inputs pasándole como argumento el estado user donde se irán guardando los valores de los inputs.\n  let errors = {}; // Creamos objeto donde iremos guardando como strings los errores en caso de que los hubiere para luego renderizarlos en pantalla.\n\n  if (!user.name) {\n    errors.name = 'name is required';\n  } // Si no hay nada en el input correspondiente al name, creamos una propiedad con dicho nombre en el objeto errors para renderizar que el name es necesaria.\n  else if (!/\\S+@\\S+\\.\\S+/.test(user.name)) {\n    errors.name = 'name is invalid';\n  } // Testeamos usando regular expressions si lo escrito en el input name es un name válido (en este caso si es un mail). Si es inválido creamos una propiedad en el objeto errors para renderizar que el name es inválido.\n  else if (!user.description) {\n    errors.description = 'description is required';\n  } // Si no hay nada en el input correspondiente al description, creamos una propiedad con dicho nombre en el objeto errors para renderizar que la description es necesaria.\n  else if (!/(?=.*[0-9])/.test(user.description)) {\n    errors.description = 'description is invalid';\n  } // Testeamos usando regular expressions si lo escrito en el input description es una description válida (en este caso si contiene al menos un número). Si es inválida creamos una propiedad en el objeto errors para renderizar que la description es inválida.\n\n\n  return errors; // Retornamos el objeto errores.\n}\nexport default function Form() {\n  _s();\n\n  const [user, setUser] = React.useState({\n    // Creamos estado de usuario donde se guardarán los valores de los inputs ingresados por el usuario en las siguientes propiedades:\n    name: '',\n    // declaramos el estado inicial de name y description como strings vacíos (nuestros inputs se mostrarán sin texto)\n    description: ''\n  });\n  const [errors, setErrors] = React.useState({}); // Creamos estado de errores para ir mostrando al usuario en caso de que sus inputs no sean validos. Declaramos su estado inicial como un objeto vacío.\n\n  const handleOnChange = e => {\n    // Declaramos función para ir manejando los cambios de estado a medida que hay cambios en los inputs. \n    setUser({ ...user,\n      [e.target.name]: e.target.value\n    }); // Actualizamos el estado de user al cual, utilizando destructuring, le agregaremos a lo que ya esté en el estado (en este caso un objeto) una propiedad con el nombre del input correspondiente y le asignaremos el valor ingresado al input.\n\n    setErrors(validate({ ...user,\n      [e.target.name]: e.target.value\n    })); // Actualizamos el estado de errors pasándole la función validadora. El argumento será nuestro estado user en cual buscaremos una propiedad que coincida con el nombre del atributo del input correspondiente y le asignaremos a dicha propiedad el value ingresado al input. Si alguno de los inputs no son válidos, la función nos devolverá un objeto errors con la propiedad name/description según corresponda y el texto de invalidación para dar aviso al usuario del error.\n  };\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"form\", {\n      children: [/*#__PURE__*/_jsxDEV(\"label\", {\n        htmlFor: \"name\",\n        children: \"Name:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 32,\n        columnNumber: 10\n      }, this), \" \", /*#__PURE__*/_jsxDEV(\"input\", {\n        className: errors.name && 'danger',\n        type: \"text\",\n        name: \"name\",\n        value: user.name,\n        onChange: handleOnChange\n      }, 'name', false, {\n        fileName: _jsxFileName,\n        lineNumber: 33,\n        columnNumber: 10\n      }, this), \" \", errors.name && /*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"danger\",\n        children: errors.name\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 34,\n        columnNumber: 27\n      }, this), \" \", /*#__PURE__*/_jsxDEV(\"label\", {\n        htmlFor: \"description\",\n        children: \"Description:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 35,\n        columnNumber: 10\n      }, this), \" \", /*#__PURE__*/_jsxDEV(\"input\", {\n        className: errors.description && 'danger',\n        type: \"description\",\n        name: \"description\",\n        value: user.description,\n        onChange: handleOnChange\n      }, 'description', false, {\n        fileName: _jsxFileName,\n        lineNumber: 36,\n        columnNumber: 10\n      }, this), \" \", errors.description && /*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"danger\",\n        children: errors.description\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 37,\n        columnNumber: 33\n      }, this), \" \", /*#__PURE__*/_jsxDEV(\"input\", {\n        type: \"submit\",\n        value: \"CREATE!\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 38,\n        columnNumber: 10\n      }, this), \" \"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 31,\n      columnNumber: 8\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 30,\n    columnNumber: 8\n  }, this);\n}\n\n_s(Form, \"MP7b3yCjiQWCU/WiKq7aORvIkeM=\");\n\n_c = Form;\n\nvar _c;\n\n$RefreshReg$(_c, \"Form\");","map":{"version":3,"names":["React","NavLink","validate","user","errors","name","test","description","Form","setUser","useState","setErrors","handleOnChange","e","target","value"],"sources":["/Users/joaco/Desktop/Henry/PI-videogames/PI-Videogames-main/client/src/components/Form/Form.js"],"sourcesContent":["import React from 'react';\nimport { NavLink } from 'react-router-dom';\nimport './Form.css';\n\nexport function validate(user) { // Creamos función validadora de datos de los inputs pasándole como argumento el estado user donde se irán guardando los valores de los inputs.\n    let errors = {}; // Creamos objeto donde iremos guardando como strings los errores en caso de que los hubiere para luego renderizarlos en pantalla.\n    if (!user.name) {errors.name = 'name is required'} // Si no hay nada en el input correspondiente al name, creamos una propiedad con dicho nombre en el objeto errors para renderizar que el name es necesaria.\n    else if (!/\\S+@\\S+\\.\\S+/.test(user.name)) {errors.name = 'name is invalid'} // Testeamos usando regular expressions si lo escrito en el input name es un name válido (en este caso si es un mail). Si es inválido creamos una propiedad en el objeto errors para renderizar que el name es inválido.\n    else if (!user.description) {errors.description = 'description is required'} // Si no hay nada en el input correspondiente al description, creamos una propiedad con dicho nombre en el objeto errors para renderizar que la description es necesaria.\n    else if (!/(?=.*[0-9])/.test(user.description)) {errors.description = 'description is invalid'} // Testeamos usando regular expressions si lo escrito en el input description es una description válida (en este caso si contiene al menos un número). Si es inválida creamos una propiedad en el objeto errors para renderizar que la description es inválida.\n    return errors; // Retornamos el objeto errores.\n  }\n\nexport default function Form() {\n    const [user, setUser] = React.useState ({ // Creamos estado de usuario donde se guardarán los valores de los inputs ingresados por el usuario en las siguientes propiedades:\n        name: '', // declaramos el estado inicial de name y description como strings vacíos (nuestros inputs se mostrarán sin texto)\n        description: ''\n        });\n\n const [errors, setErrors] = React.useState({}) // Creamos estado de errores para ir mostrando al usuario en caso de que sus inputs no sean validos. Declaramos su estado inicial como un objeto vacío.\n\n const handleOnChange = (e) => { // Declaramos función para ir manejando los cambios de estado a medida que hay cambios en los inputs. \n    setUser({...user, [e.target.name]: e.target.value}) // Actualizamos el estado de user al cual, utilizando destructuring, le agregaremos a lo que ya esté en el estado (en este caso un objeto) una propiedad con el nombre del input correspondiente y le asignaremos el valor ingresado al input.\n    setErrors(validate({...user, [e.target.name]: e.target.value})) // Actualizamos el estado de errors pasándole la función validadora. El argumento será nuestro estado user en cual buscaremos una propiedad que coincida con el nombre del atributo del input correspondiente y le asignaremos a dicha propiedad el value ingresado al input. Si alguno de los inputs no son válidos, la función nos devolverá un objeto errors con la propiedad name/description según corresponda y el texto de invalidación para dar aviso al usuario del error.\n }\n   \n\n\n    return (\n       <div>\n       <form>\n         <label htmlFor='name'>Name:</label> {/*Creamos etiqueta name con su respectivo input de texto (declaramos su key para que React pueda diferenciarlo del otro).*/}\n         <input className={errors.name && 'danger'} type='text' name='name' key='name' value={user.name} onChange={handleOnChange}></input> {/* Creamos input de tipo texto donde el usuario podrá ingresar su name(un email). Su clase solo será 'danger' si, mediante la función validadora, hay algún error en el input; esto hará que el borde del input se ponga en rojo debido al css aplicado. Su value será igual a la propiedad name de nuestro user el cual se almacenará gracias a la función handleOnChange que se ejecutará en cada evento onChange (cada vez que haya un cambio en el input.) */}\n         {errors.name && (<p className='danger'>{errors.name}</p>)} {/* Si hay algún error en el input del name, es decir si errors.name es truthy (no es null), renderizamos un tag de párrafo que muestre el valor guardado en esa propiedad. En este caso la string correspondiente al error.  */}\n         <label htmlFor='description'>Description:</label> {/*Creamos etiqueta description con su respectivo input de texto (declaramos su key para que React pueda diferenciarlo del otro).*/}\n         <input className={errors.description && 'danger'} type='description' name='description' key='description' value={user.description} onChange={handleOnChange}></input> {/* Creamos input de tipo texto donde el usuario podrá ingresar su description. Su clase solo será 'danger' si, mediante la función validadora, hay algún error en el input; esto hará que el borde del input se ponga en rojo debido al css aplicado. Su value será igual a la propiedad description de nuestro user el cual se almacenará gracias a la función handleOnChange que se ejecutará en cada evento onChange (cada vez que haya un cambio en el input.) */}\n         {errors.description && <p className='danger'>{errors.description}</p>} {/* Si hay algún error en el input del description, es decir si errors.description es truthy (no es null), renderizamos un tag de párrafo que muestre el valor guardado en esa propiedad. En este caso la string correspondiente al error.  */}\n         <input type='submit' value='CREATE!'></input> {/*Creamos input de tipo submit para poder submitear el form. */}\n       </form> \n      </div>\n    )\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}